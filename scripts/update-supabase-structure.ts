/**
 * update-supabase-structure.ts
 *
 * Reads prisma/schema.prisma and generates docs/supabase-structure.md.
 * Run: npm run gen:db-docs   (or: npx tsx scripts/update-supabase-structure.ts)
 *
 * Hooking into your workflow:
 *   - Post-migrate:  add "postmigrate": "npm run gen:db-docs" to package.json
 *   - Pre-commit:    npx lint-staged with "*.prisma": ["npm run gen:db-docs", "git add docs/supabase-structure.md"]
 *   - CI:            run gen:db-docs and fail if docs/supabase-structure.md has uncommitted changes
 */

import * as fs from "fs";
import * as path from "path";

const ROOT = path.resolve(__dirname, "..");
const SCHEMA_PATH = path.join(ROOT, "prisma", "schema.prisma");
const OUTPUT_PATH = path.join(ROOT, "docs", "supabase-structure.md");

interface Field {
  name: string;
  type: string;
  isOptional: boolean;
  isArray: boolean;
  attributes: string[];
  rawLine: string;
}

interface Model {
  name: string;
  fields: Field[];
  blockAttributes: string[];
}

function toSnakeCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, "$1_$2")
    .replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2")
    .toLowerCase();
}

function parsePrismaSchema(content: string): Model[] {
  const models: Model[] = [];
  const modelRegex = /model\s+(\w+)\s*\{([^}]+)\}/g;
  let match: RegExpExecArray | null;

  while ((match = modelRegex.exec(content)) !== null) {
    const modelName = match[1];
    const body = match[2];
    const fields: Field[] = [];
    const blockAttributes: string[] = [];

    for (const rawLine of body.split("\n")) {
      const line = rawLine.trim();
      if (!line || line.startsWith("//")) continue;

      if (line.startsWith("@@")) {
        blockAttributes.push(line);
        continue;
      }

      const fieldMatch = line.match(/^(\w+)\s+(\w+)(\[\])?\s*(\?)?\s*(.*)/);
      if (!fieldMatch) continue;

      const [, name, type, isArray, isOptional, rest] = fieldMatch;
      const attributes = rest ? rest.match(/@[\w.]+(\([^)]*\))?/g) || [] : [];

      fields.push({
        name,
        type,
        isOptional: !!isOptional || !!isArray,
        isArray: !!isArray,
        attributes: attributes.map((a) => a.trim()),
        rawLine: line,
      });
    }

    models.push({ name: modelName, fields, blockAttributes });
  }

  return models;
}

function prismaTypeToSql(type: string): string {
  const map: Record<string, string> = {
    String: "TEXT",
    Int: "INTEGER",
    Float: "DOUBLE PRECISION",
    Decimal: "DECIMAL",
    Boolean: "BOOLEAN",
    DateTime: "TIMESTAMPTZ",
    Json: "JSONB",
    BigInt: "BIGINT",
    Bytes: "BYTEA",
  };
  return map[type] || type;
}

function extractDefault(attributes: string[]): string {
  const def = attributes.find((a) => a.startsWith("@default"));
  if (!def) return "";
  const inner = def.match(/\(([^)]+)\)/);
  if (!inner) return "";
  return `DEFAULT ${inner[1]}`;
}

function isRelationField(field: Field): boolean {
  return field.attributes.some((a) => a.startsWith("@relation"));
}

function isPk(field: Field): boolean {
  return field.attributes.some((a) => a === "@id");
}

function isUnique(field: Field): boolean {
  return field.attributes.some((a) => a === "@unique");
}

function extractFk(field: Field, allModels: Model[]): string | null {
  const relAttr = field.attributes.find((a) => a.startsWith("@relation"));
  if (!relAttr) return null;
  const fieldsMatch = relAttr.match(/fields:\s*\[([^\]]+)\]/);
  const refsMatch = relAttr.match(/references:\s*\[([^\]]+)\]/);
  if (fieldsMatch && refsMatch) {
    return `${fieldsMatch[1].trim()} → ${field.type}.${refsMatch[1].trim()}`;
  }
  return null;
}

function generateMarkdown(models: Model[]): string {
  const now = new Date().toISOString().split("T")[0];
  const lines: string[] = [];

  lines.push(`<!--`);
  lines.push(`  ╔══════════════════════════════════════════════════════════╗`);
  lines.push(`  ║  GENERATED FILE — DO NOT EDIT MANUALLY                  ║`);
  lines.push(`  ║                                                         ║`);
  lines.push(`  ║  This file is auto-generated by:                        ║`);
  lines.push(`  ║    npm run gen:db-docs                                  ║`);
  lines.push(`  ║  Source: prisma/schema.prisma                           ║`);
  lines.push(`  ║                                                         ║`);
  lines.push(`  ║  Any manual edits will be overwritten on next run.      ║`);
  lines.push(`  ║  To update, modify the Prisma schema and re-run the     ║`);
  lines.push(`  ║  script.                                                ║`);
  lines.push(`  ╚══════════════════════════════════════════════════════════╝`);
  lines.push(`-->`);
  lines.push(``);
  lines.push(`# OutfAI — Supabase / Database Structure`);
  lines.push(``);
  lines.push(
    `> Auto-generated from \`prisma/schema.prisma\` by [\`scripts/update-supabase-structure.ts\`](../scripts/update-supabase-structure.ts).`
  );
  lines.push(`> Last generated: ${now}`);
  lines.push(``);
  lines.push(`---`);
  lines.push(``);
  lines.push(`## How This File Is Generated`);
  lines.push(``);
  lines.push(
    `1. The Prisma schema at \`prisma/schema.prisma\` is the single source of truth for the database.`
  );
  lines.push(`2. Run \`npm run gen:db-docs\` to regenerate this file.`);
  lines.push(
    `3. The script parses every \`model\` block and extracts columns, types, constraints, relations, and indexes.`
  );
  lines.push(`4. **Hook into your workflow:**`);
  lines.push(
    `   - Post-migrate: add \`"postmigrate": "npm run gen:db-docs"\` to \`package.json\` scripts`
  );
  lines.push(
    `   - Pre-commit: add \`npm run gen:db-docs && git add docs/supabase-structure.md\` to your pre-commit hook`
  );
  lines.push(``);
  lines.push(`---`);
  lines.push(``);

  // Table list
  lines.push(`## Table List`);
  lines.push(``);
  lines.push(`| Table | Prisma Model | Columns |`);
  lines.push(`|-------|-------------|---------|`);
  for (const model of models) {
    const tableName = toSnakeCase(model.name) + "s";
    const colCount = model.fields.filter(
      (f) => !isRelationField(f) && !f.isArray
    ).length;
    lines.push(`| \`${tableName}\` | \`${model.name}\` | ${colCount} |`);
  }
  lines.push(``);
  lines.push(`---`);
  lines.push(``);

  // Per-model detail
  lines.push(`## Table Definitions`);
  lines.push(``);

  for (const model of models) {
    const tableName = toSnakeCase(model.name) + "s";
    lines.push(`### \`${tableName}\``);
    lines.push(``);

    const dataFields = model.fields.filter(
      (f) => !isRelationField(f) && !f.isArray
    );

    lines.push(`| Column | Type | Constraints | Default |`);
    lines.push(`|--------|------|-------------|---------|`);

    for (const field of dataFields) {
      const colName = toSnakeCase(field.name);
      const sqlType = prismaTypeToSql(field.type);
      const constraints: string[] = [];
      if (isPk(field)) constraints.push("PK");
      if (isUnique(field)) constraints.push("UNIQUE");
      if (!field.isOptional && !isPk(field)) constraints.push("NOT NULL");
      const defaultVal = extractDefault(field.attributes);
      lines.push(
        `| \`${colName}\` | \`${sqlType}\` | ${constraints.join(", ") || "—"} | ${defaultVal || "—"} |`
      );
    }
    lines.push(``);

    // Indexes from block attributes
    const indexes = model.blockAttributes.filter(
      (a) => a.startsWith("@@index") || a.startsWith("@@unique")
    );
    if (indexes.length > 0) {
      lines.push(`**Indexes:**`);
      for (const idx of indexes) {
        const colsMatch = idx.match(/\(\[([^\]]+)\]\)/);
        const type = idx.startsWith("@@unique") ? "UNIQUE" : "INDEX";
        if (colsMatch) {
          const cols = colsMatch[1]
            .split(",")
            .map((c) => toSnakeCase(c.trim()));
          lines.push(
            `- ${type} on (${cols.map((c) => `\`${c}\``).join(", ")})`
          );
        }
      }
      lines.push(``);
    }

    // Foreign keys from relation fields
    const relationFields = model.fields.filter(
      (f) => isRelationField(f) && !f.isArray
    );
    const fks: string[] = [];
    for (const rf of relationFields) {
      const fk = extractFk(rf, models);
      if (fk) fks.push(fk);
    }
    if (fks.length > 0) {
      lines.push(`**Foreign keys:**`);
      for (const fk of fks) {
        const [local, remote] = fk.split(" → ");
        lines.push(
          `- \`${toSnakeCase(local.trim())}\` → \`${toSnakeCase(remote.split(".")[0])}s.${toSnakeCase(remote.split(".")[1])}\``
        );
      }
      lines.push(``);
    }

    lines.push(`---`);
    lines.push(``);
  }

  // Relationships
  lines.push(`## Relationships`);
  lines.push(``);
  lines.push("```");
  for (const model of models) {
    const relations = model.fields.filter((f) => f.isArray);
    if (relations.length === 0) continue;
    const tableName = toSnakeCase(model.name) + "s";
    lines.push(tableName);
    for (const rel of relations) {
      const targetTable = toSnakeCase(rel.type) + "s";
      lines.push(`  └── 1:N → ${targetTable}`);
    }
    lines.push(``);
  }
  lines.push("```");
  lines.push(``);

  // Migrations placeholder
  lines.push(`---`);
  lines.push(``);
  lines.push(`## Migrations History`);
  lines.push(``);
  lines.push(`| Migration | Date | Description |`);
  lines.push(`|-----------|------|-------------|`);
  lines.push(
    `| _(none yet)_ | — | Run \`npx prisma migrate dev --name init\` to create the initial migration. |`
  );
  lines.push(``);

  return lines.join("\n");
}

function main() {
  if (!fs.existsSync(SCHEMA_PATH)) {
    console.warn(`⚠  Prisma schema not found at ${SCHEMA_PATH}`);
    console.warn(`   Generating placeholder docs/supabase-structure.md`);
    console.warn(
      `   Create prisma/schema.prisma and re-run to generate full docs.`
    );

    const placeholder = [
      `<!--`,
      `  GENERATED FILE — DO NOT EDIT MANUALLY`,
      `  Run: npm run gen:db-docs`,
      `-->`,
      ``,
      `# OutfAI — Supabase / Database Structure`,
      ``,
      `> **Schema not found.** No \`prisma/schema.prisma\` detected.`,
      `>`,
      `> To generate this file:`,
      `> 1. Create the Prisma schema at \`prisma/schema.prisma\``,
      `> 2. Run \`npm run gen:db-docs\``,
      ``,
      `See [OutfAI_Database_Design.md](./OutfAI_Database_Design.md) for the planned schema.`,
      ``,
    ].join("\n");

    fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
    fs.writeFileSync(OUTPUT_PATH, placeholder, "utf-8");
    console.log(`✓  Wrote placeholder to ${OUTPUT_PATH}`);
    return;
  }

  const schemaContent = fs.readFileSync(SCHEMA_PATH, "utf-8");
  const models = parsePrismaSchema(schemaContent);

  if (models.length === 0) {
    console.warn(`⚠  No models found in ${SCHEMA_PATH}`);
    return;
  }

  const markdown = generateMarkdown(models);

  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_PATH, markdown, "utf-8");

  console.log(
    `✓  Generated ${OUTPUT_PATH} with ${models.length} table(s) from Prisma schema.`
  );
}

main();
